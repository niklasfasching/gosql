* WIP
a minimalist go sql wrapper that makes sense for the kind of projects i plan to do
which is: exposing sqlite databases to the internet - as in allowing sql statements over http. yep... let's see how bad that really is

#+begin_src go
func main() {
	db := &DB{DataSourceName: "./data.sqlite", ReadOnly: true}
	if err := db.Open(); err != nil {
		log.Fatal(err)
	}
	http.Handle("/api", db.Handler())
	log.Fatal(http.ListenAndServe(":8000", nil))
}
#+end_src

#+begin_src bash
$ curl localhost:8000/api --silent --get --data-urlencode "query=SELECT * FROM sqlite_master LIMIT 1" | jq .
# [
#     {
#         "name": "migrations",
#         "rootpage": 2,
#         "sql": "CREATE TABLE `migrations` (name STRING, timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP)",
#         "tbl_name": "migrations",
#         "type": "table"
#     }
# ]
#+end_src
* security concerns
- read only databases (mode=ro) still allow stuff like =attach database 'foobar.sqlite' as foobar= and thus gain access to other stuff
- also pragma are available
- attach can be disabled via limit attach
- but actually, there's an authorizer interface!

-> https://stackoverflow.com/questions/3738328/safe-read-only-sqlite3-database
* features

SELECT * FROM sqlite_master
-> returns schema! .sql contains the original create table statement
-> can use that to expose a pretty schema, just like graphql!
